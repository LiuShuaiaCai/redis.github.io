{"./":{"url":"./","title":"Introduction","keywords":"","body":"Redis数据结构 Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-03-11 12:48:31 "},"redis/config/":{"url":"redis/config/","title":"配置文件","keywords":"","body":"配置文件的单位说明 关于单位的说明：当需要内存大小时，可以以1k 5GB 4M等通常形式指定： 1k=>1000字节 1kb=>1024字节 1m=>1000000字节 1mb=>1024*1024字节 1g=>1000000000字节 1gb=>1024*1024*1024字节 单位不区分大小写，因此1GB 1Gb 1gB都相同。 引入其它配置（INCLUDES） # 包含其他配置文件，将redis的配置分离管理时使用 # include /path/to/local.conf # include /path/to/other.conf 模块（MODULES） # 引入自定义模块来新增一些功能。 # loadmodule /path/to/my_module.so # loadmodule /path/to/other_module.so 网络配置（NETWORK） 网络监听 使用bind指令指定监听的IP，默认情况下，如果未指定“bind”配置指令，Redis将侦听服务器上所有可用网络接口的连接。 bind 127.0.0.1 可以使用“bind”配置指令，后跟一个或多个IP地址。 # bind 192.168.1.100 10.0.0.1 # bind 127.0.0.1 ::1 监听端口 接受指定端口上的连接，默认值为6379，如果指定端口0，Redis将不会侦听TCP套接字。 port 6379 保护模式 保护模式是一层安全保护，以避免在互联网上打开的Redis实例被访问和利用，默认是开启状态 protected-mode yes TCP队列长度 在linux系统中控制tcp三次握手已完成连接队列的长度。 在高并发系统中，你需要设置一个较高的tcp-backlog来避免客户端连接速度慢的问题（三次握手的速度) tcp-backlog 511 注意事项： 1、已完成连接队列的长度也与操作系统中/proc/sys/net/core/somaxconn有关，取二者最小min(tcp-backlog,somaxconn) // linux查看已完成连接队列的长度 $ /proc/sys/net/core/somaxconn //mac查看已完成连接队列的长度 $ sysctl -a|grep somaxconn 2、已完成连接队列又与半连接队列长度有关 // linux查看半连接队列长度 $ /proc/sys/net/ipv4/tcp_max_syn_backlog //mac查看半连接队列长度 $ sysctl -a|grep backlog 3、简要介绍下半连接与已完成连接 半连接：服务端收到客户端syn后,将连接放入半连接队列。如果半连接队列已满会丢弃，客户端报错connection time out。 已完成连接：服务端收到客户端的ack后，从半连接队列中拿出连接放入已完成连接队列。如果已完成连接队列已经满则无法放入，客户端报错read timeout或者connection reset by peer 超时时间 客户端空闲N秒后关闭连接（0表示禁用） timeout 0 长链接 如果非零，则使用SO_KEEPALIVE在没有通信的情况下向客户端发送TCP ACK。这有两个原因： 检测死对等体。 从在中间网络设备的角度来看，连接是活的。 在Linux上，指定的值（以秒为单位）是用于发送ACK的时间段。 请注意，要关闭连接，需要双倍的时间。 在其他内核上，周期取决于内核配置。 此选项的合理值为300秒，这是从Redis 3.2.1开始的新Redis默认值。 tcp-keepalive 300 常规配置（GENERAL） # 默认情况下，Redis不作为守护程序运行。如果需要，请使用`yes`，当守护进程化时，Redis将在/var/run/Redis.pid中写入一个pid文件。 daemonize no # 若从upstart或systemd运行Redis，则Redis可以与监控树交互。 #+ supervised no -无相互监督 #+ supervised upstart - 使Redis进入SIGSTOP模式并监控upstart #+ supervised systemd - 通过设置READY=1到$NOTIFY_SOCKET来监控systemd #+ supervised auto - 基于UPSTART_JOB或NOTIFY_SOCKET环境变量的监督自动检测upstart或systemd方法 supervised no # 配置PID文件路径，当redis以守护进程运行时，它会将pid默认写到/var/run/redis_6379.pid文件中 pidfile /var/run/redis_6379.pid # 日志级别(debug/verbose/notice/warning)，默认为notice loglevel notice # 指定日志文件名。空字符串也可以用于强制Redis登录标准输出。注意，如果您使用标准输出进行日志记录，但使用后台进程，则日志将被发送到/dev/null logfile \"\" # 系统日志设置，要启用系统日志记录，只需将`syslog enabled`设置为`yes`，默认为no # syslog-enabled no # 指定syslog标识。 # syslog-ident redis # 指定syslog工具。必须是USER或介于LOCAL0-LOCAL7之间。 # syslog-facility local0 # 设置数据库数量 databases 16 # 默认logo标识只在交互回话中显示。 # 该设置可以设置始终在启动日志中显示ASCII art徽标。 always-show-logo yes 快照设置（SNAPSHOTTING） # 指定多长时间内(秒)，有多少次更新操作，就将数据同步到磁盘，可以多条件配合 # save # save \"\" 可以设置为空完全禁用保存 save 900 1 # 900s内至少有1次更新操作则保存 save 300 10 # 300s内至少有10次更新操作则保存 save 60 10000 # 60s内至少有10000次更新操作则保存 # 当启用RDB最后一次后台保存数据失败，redis停止接受数据，以通知用户数据没有正确持久化到磁盘中。 stop-writes-on-bgsave-error yes # 指定存储至本地数据库时是否压缩数据，默认为yes。关闭压缩会节省CPU时间，但会导致数据文件变大 rdbcompression yes # 存储快照后，让redis使用CRC64算法进行数据校验，但是增大了性能消耗，在保存和加载RDB文件时约10%性能消耗。 rdbchecksum yes # 指定rdb文件名 dbfilename dump.rdb # 指定本地数据库存放位置 dir ./ 主从复制（REPLICATION） # 用replicaof使Redis实例成为另一个Redis服务器的副本 replicaof # 当master服务设置了密码保护是，slave服务连接master的密码 masterauth #当一个slav和一个master是去联系或在进行复制时，slave是否进行响应。 # yes：Slave扔会应答请求，但返回数据可能已过时，或者数据为空 # no：在执行info he slaveof 之外的命令时，slave将返回一个\"SYNC with master in progress\" slave-serve-stale-data yes # slave是否只读 slave-read-only yes # 主从数据复制是否使用无硬盘复制功能 repl-diskless-sync no # 当启用无盘复制时，可以配置服务器等待的延迟，以便生成通过套接字将RDB传输到副本的子级。 # 这一点很重要，因为一旦传输开始，就不可能为到达的新副本提供服务，这些副本将排队等待下# 延迟以秒为单位指定，默认情况下为5秒。要完全禁用它，只需将其设置为0秒，传输将尽快开始。 repl-diskless-sync-delay 5 # 从服务器以预定义的时间间隔向服务器发送ping信号。默认值是10秒。 # repl-ping-slave-period 10 # 以下选项设置的复制超时： #1）从副本的角度来看，SYNC期间的批量传输I/O。 #2）从副本（数据、ping）的角度来看，主超时。 #3）从主机的角度来看，副本超时（REPLCONF ACK ping）。 # 务必确保该值大于repl-ping-replica-period的值，否则每次主服务器和复制副本之间的通信量低时都会检测到超时。 # repl-timeout 60 # 在SYNC之后禁用复制套接字上的TCP_NODELAY？ # 如果选择“yes”，Redis将使用更少的TCP数据包和更少的带宽向副本发送数据。但这可能会增加数据出现在副本端的延迟，对于使用默认配置的Linux内核，延迟可达40毫秒。 # 如果选择“no”，数据出现在副本侧的延迟将减少，但复制将使用更多的带宽。 # 默认情况下，我们针对低延迟进行优化，但在非常高的流量条件下，或者当主服务器和副本相隔很远时，将此设置为“是”可能是一个好主意。 repl-disable-tcp-nodelay no # 设置复制积压工作的大小。backlog是一个缓冲区，当副本断开连接一段时间时，它会累积副本数据，因此当副本想要再次连接时，通常不需要完全重新同步，但部分重新同步就足够了，只需传递断开连接时副本丢失的部分数据。 # 复制积压越大，复制副本断开连接的时间就越长，以后可以执行部分重新同步。 # 只有在至少连接了一个副本时，才会分配积压工作。 # repl-backlog-size 1mb # 主服务器在一段时间内(从上一个副本断开连接开始)不再连接副本后，将backlog被释放。 # 注意，副本永远不会释放backlog以等待超时，因为它们可能会在以后升级为主副本，并且应该能够正确地与副本“部分重新同步”：因此它们应该始终累积backlog。 # 值为0表示从不释放backlog。 # repl-backlog-ttl 3600 #slave节点的优先级，低优先的slave节点更容易被提升为master节点 # 优先级为0，则该slave节点不能被提升为master节点 slave-priority 100 # 如果连接的副本少于N个，且延迟小于或等于M秒，则主机可以停止接受写入。 # N个副本需要处于“在线”状态。 # 延迟（以秒为单位，必须 安全（SECURITY） # 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时 # 需要通过AUTH 命令提供密码，默认关闭 # requirepass foobared # 重新命名命令，例如：rename-command command1 newName # 也可以禁用某个命令，例如禁用config命令：rename-command CONFIG \"\" # 请注意，更改记录到AOF文件或传输到副本的命令的名称可能会导致问题 # rename-command command1 newName 客户端（CLIENTS） # 允许最大客户端连接数 maxclients 10000 内存管理（MEMORY MANAGEMENT） # 限制Redis最大内存（单位：bytes） # 当达到内存限制时，Redis将尝试根据maxmemory-policy设置的淘汰策略进行内存优化 # 如果Redis无法根据策略删除密钥，或者如果策略设置为“noevision”，则Redis将开始对使用更多内存的命令（如set、LPUSH等）进行错误回复，并继续对GET等只读命令进行回复。 # 当使用Redis作为LRU或LFU缓存，或为实例设置硬内存限制（使用“noevision”策略）时，此选项通常很有用。 # 警告：如果您将副本附加到启用了maxmemory的实例，则从已用内存计数中减去馈送副本所需的输出缓冲区的大小，这样网络问题/重新同步将不会触发密钥被逐出的循环，进而副本的输出缓冲池已满，被逐出的密钥的DEL将触发更多密钥的删除，等等，直到数据库被完全清空。 # 简而言之。。。如果附加了副本，建议您设置maxmemory的下限，以便系统上有一些可用的RAM用于副本输出缓冲区（但如果策略为“noevision”，则不需要这样做）。 # maxmemory # 内存淘汰策略 # volatile-lru -> 使用LRU算法移除key，只针对设置了过期时间的key. # allkeys-lru -> 使用LRU算法移除key，对所有key. # volatile-lfu -> 使用LFU算法移除key，只针对设置了过期时间的key. # allkeys-lfu -> 使用LFU算法移除key，对所有key. # volatile-random -> 在过期集合中随之移除key，只对设置了过期时间的key # allkeys-random -> 在过期集合中随之移除key，对所有key. # volatile-ttl -> 移除那些TTL最小的key，即最近要过期的key # noeviction -> 永不过期，内存满时直接报错（默认值） # LRU表示最近最少使用 # LFU表示最不常用 # maxmemory-policy noeviction # 设置检验样本数 # LRU、LFU和最小TTL算法不是精确算法，而是近似算法（为了节省内存），因此您可以调整其速度或精度。默认情况下，Redis将检查五个键并选择最近使用较少的键，您可以使用以下配置指令更改样本大小。 # 默认值为5会产生足够好的结果。10非常接近真实的LRU，但需要更多的CPU。3的速度更快，但不是很准确。 # maxmemory-samples 5 # 从服务是否忽略最大内存限制 # 从Redis 5开始，默认情况下，副本将忽略其最大内存设置（除非在故障切换后或手动将其升级为主副本）。这意味着淘汰key的操作将只由主机处理，当密钥在主机端逐出时，向副本发送DEL命令。 # replica-ignore-maxmemory yes 惰性释放（LAZY FREEING） # 对不同数据的删除策略，设置是否阻塞 # Redis删除数据FLUSHALL和FLUSHDB的DEL、UNLINK和ASYNC选项由用户控制，且默认都是阻塞的。 lazyfree-lazy-eviction no lazyfree-lazy-expire no lazyfree-lazy-server-del no slave-lazy-flush no 数据文件记录模式（APPEND ONLY MODE） # 是否每次更新后进行日志记录。Redis默认异步将数据写入磁盘，数据在一段时间内只存在于内存中。 appendonly no # 指定更新日志文件名 appendfilename \"appendonly.aof\" #指定更新日志条件 # no表示等操作系统进行数据缓存同步到磁盘（快） # always 表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） # everysec 每秒同步一次（折中，默认值） appendfsync everysec # 设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。 # Linux的默认fsync策略是30秒。可能丢失30秒数据. no-appendfsync-on-rewrite no # 当AOF日志大小增长指定的百分比时，Redis能够自动调用BGREWRITEEAOF命令对日志文件重写。 # 工作原理：Redis会记住最近一次重写后AOF文件的大小（如果重新启动后没有发生重写，则使用启动时AOF的大小）。 # 将此基本尺寸与当前尺寸进行比较。如果当前大小大于指定的百分比，将触发重写。此外，您需要指定要重写的AOF文件的最小大小，这对于避免重写AOF文件非常有用，即使达到了百分比增加，但仍然非常小。 # 指定零的百分比以禁用自动AOF重写功能。 auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb # 在Redis启动过程中，当AOF数据加载回内存时，可能会发现AOF文件在最后被截断。 # 当运行Redis的系统崩溃时，可能会发生这种情况，特别是在安装ext4文件系统时没有data=ordered选项（但是，当Redis本身崩溃或中止但操作系统仍正常工作时，这种情况不会发生）。 # 当发生这种情况时，Redis可以退出并返回错误，或者加载尽可能多的数据（现在是默认值），如果发现AOF文件在结尾处被截断，则重新启动。以下选项控制此行为： # 如果aof-load-truncated设置为yes，则会加载一个被截断的aof文件，并且Redis服务器会开始发出日志通知用户该事件。 # 如果aof-load-truncated置为no，服务器将因错误而中止并拒绝启动。用户需要在重新启动服务器之前使用“redis-check-aof”修复AOF文件。 #请注意，如果发现AOF文件在中间损坏，服务器仍将退出并返回错误。只有当Redis尝试从AOF文件中读取更多数据，但找不到足够的字节时，此选项才适用。 aof-load-truncated yes # 是否开启混合持久化 # 开启后，当重写AOF文件时，Redis能够在AOF文件中使用RDB前导码，以便更快地进行重写和恢复。 # 启用此选项后，重写的AOF文件由两个不同的节组成：[RDB file][AOF tail] # 当加载Redis识别到AOF文件以“Redis”字符串开头，并加载带有前缀的RDB文件，然后继续加载AOF尾部 aof-use-rdb-preamble yes LUA脚本（LUA SCRIPTING） # Lua脚本的最大执行时间（毫秒） lua-time-limit 5000 Redis集群（REDIS CLUSTER） #是否开启集群，默认不开启 # cluster-enabled yes # 集群配置文件名称。每个节点都有一个单独的集群相关的配置文件，持久化保存集群信息。 # 这个文件不需要手动配置，由redis自动生成并更新。 # 名称不能重复 # cluster-config-file nodes-6379.conf # 节点之间互联超时的阀值，ms # cluster-node-timeout 15000 #用于判断slave节点和master断开的时间阀值，超过该值slave节点不能申请成为master节点。 # cluster-slave-validity-factor 10 # master的slave数大于该值，slave则能迁移到其他孤立的master上 # cluster-migration-barrier 1 # 默认情况下，如果Redis群集节点检测到至少有一个哈希槽未覆盖（没有可用节点为其提供服务），则会停止接受查询。 # 这样，如果集群部分关闭（例如，不再覆盖一系列哈希槽），则所有集群最终都将不可用。一旦再次覆盖所有插槽，它就会自动返回可用状态。 # 然而，有时您希望正在工作的集群的子集继续接受对仍然覆盖的部分密钥空间的查询。为此，只需将集群cluster-require-full-coverage选项设置为no。 # cluster-require-full-coverage yes # 设置是否进行故障转移，如果设置为yes，则将阻止master故障时进行故障转移，但仍可以手动强制进行故障转移；（在一些特定场景下可能用得到） # cluster-replica-no-failover no 集群总线/NAT设置（CLUSTER DOCKER/NAT support） # 在某些部署中，Redis集群节点地址发现失败，因为地址是NAT-ted的或者因为端口被转发(典型的情况是Docker和其他容器)。 # 为了让Redis集群在这样的环境中工作，需要一个静态配置，指定节点的公共地址 。 # 每个节点都指示节点的地址、客户端端口和集群消息总线端口，然后将信息发布到总线包的头部，以便其他节点能够正确映射发布信息的节点的地址。 # # cluster-announce-ip 10.1.1.5 # cluster-announce-port 6379 # cluster-announce-bus-port 6380 慢日志（SLOW LOG） # 要超过多少执行时间（以微秒为单位，1000000相当于1秒）才能记录命令。请注意，负数将禁用慢速日志，而值为零将强制记录每个命令。 slowlog-log-slower-than 10000 # 慢日志的长度，此长度没有限制。只需注意它会消耗内存。 # 可以使用SLOWLOG RESET回收慢速日志使用的内存。 slowlog-max-len 128 监控延迟命令（LATENCY MONITOR） # Redis延迟监视子系统在运行时采样不同的操作，以便收集与Redis实例的潜在延迟源相关的数据。 # 通过LATENCY命令，可以将此信息提供给能够打印图形和获取报告的用户。 # 系统只记录在等于或大于通过延迟监视阀值配置指令指定的毫秒数的时间内执行的操作。 # 当它的值被设置为零时，延迟监视器将被关闭。 # 如果需要，可以在运行时使用“CONFIG SET latency-monitor-threshold >”命令轻松启用延迟监视。 latency-monitor-threshold 0 事件通知（EVENT NOTIFICATION） # Redis可以将密钥空间中发生的事件通知发布/订阅客户端。这个特性记录在http://redis.io/topics/notifications # 如果启用了keyspace事件通知，并且客户端对存储在数据库0中的key \"foo\"执行DEL操作，则两条消息将通过Pub/Sub发布: # 默认情况下，所有通知都是禁用的 notify-keyspace-events \"\" 高级设置（ADVANCED CONFIG） # 指定在超过一定的数量或最大元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-ziplist-entries 512 hash-max-ziplist-value 64 # 列表还以一种特殊的方式进行编码，以节省大量空间。 # 每个内部列表节点允许的条目数可以指定为固定的最大大小或最大元素数。 # 对于固定的最大大小，使用-5到-1，表示： # -5：最大大小：64 Kb节点- >节点- >…- >节点- >(尾巴) # [头]、[尾]永远不会被压缩;内部节点将被压缩。 # 2:[头]- >[下]- >节点- >节点- >…- >节点- >[上一页]- >(尾巴) # 这里的意思是:不要压缩head或head->next或tail->prev或tail，而是压缩它们之间的所有节点。 # 3:[头]- >[下]- >[下]- >节点- >节点- >…- >节点- >[上一页]- >[上一页]- >(尾巴) list-compress-depth 0 # 还有这样一种特殊编码的情况：数据全是64位无符号整型数字构成的字符串。 # 下面这个配置项就是用来限制这种情况下使用这种编码的最大上限的。 set-max-intset-entries 512 #与哈希和列表类似，排序集也经过特殊编码，以节省大量空间。此编码仅在排序集的长度和元素低于以下限制时使用： zset-max-ziplist-entries 128 zset-max-ziplist-value 64 # HyperLogLog稀疏表示字节限制。限制包括16个字节的头。 # 当使用稀疏表示的HyperLogLog超过此限制时，它将被转换为稠密表示。 # 大于16000的值是完全无用的，因为此时密集表示更有效。 # 建议值为0~ 3000，以在不降低太多PFADD(稀疏编码的O(N))的情况下，获得空间高效编码的优点。 # 如果不关心CPU，但关心空间，并且数据集由许多基数在0 - 15000范围内的超loglog组成，则可以将该值提高到~ 10000。 hll-sparse-max-bytes 3000 # 流宏节点最大大小/条目。 # 流数据结构是一个大节点的基数树，在其中编码多个项。使用此配置，可以配置单个节点的大小（以字节为单位），以及在附加新流条目时切换到新节点之前可能包含的最大项目数。如果以下任何设置设置为零，则该限制将被忽略，因此例如，可以通过将最大字节设置为0并将最大条目设置为所需值来仅设置最大整数限制。 stream-node-max-bytes 4096 stream-node-max-entries 100 # 是否激活重置哈希，默认开启 activerehashing yes # 客户端输出缓存限制强迫断开读取速度比较慢的客户端 # client-output-buffer-limit # 当达到强制限制缓存大小，立即断开连接；达到软性限制，仍会有软性时间大小的链接时间 # 默认正常客户端无限制，只有请求后，异步客户端数据请求速度快于它能读取数据的速度 # 订阅模式和主从客户端又默认限制，因为它们都接受推送。 # 强制限制和软性限制都可以设置为0来禁用这个特性 client-output-buffer-limit normal 0 0 0 #正常的客户端包括监控客户端 client-output-buffer-limit slave 256mb 64mb 60 #从客户端 client-output-buffer-limit pubsub 32mb 8mb 60 #客户端至少订阅了一个频道或者模式 # 客户端查询缓冲区累积新命令。默认情况下，它们被限制为固定数量，以避免协议不同步（例如，由于客户端中的错误）将导致查询缓冲区中的未绑定内存使用。但是，如果您有非常特殊的需求，例如巨大的multi/exec请求或类似请求，您可以在这里配置它。 client-query-buffer-limit 1gb # 在Redis协议中，批量请求（即表示单个字符串的元素）通常限制为512 mb # proto-max-bulk-len 512mb # 设置redis任务执行频率，如清除过期键任务、关闭超时链接的客户端 # 范围1-500，值越大CPU消耗越大，建议不超过100 hz 10 # 通常，具有与连接的客户端数量成比例的HZ值是有用的。例如，为了避免每次后台任务调用处理过多的客户端，以避免延迟峰值，这非常有用。 # 由于默认的HZ值保守地设置为10，Redis提供并在默认情况下启用了使用自适应HZ值的能力，当有许多连接的客户端时，该值将临时升高。 # 当启用动态HZ时，实际配置的HZ将用作基线，但一旦连接了更多客户端，则实际使用配置HZ值的倍数。这样，空闲实例将占用很少的CPU时间，而繁忙实例将更具响应性。 dynamic-hz yes # 当子进程重写AOF文件时，如果启用了以下选项，则该文件将每生成32 MB数据进行一次fsync。这对于更多增量地将文件提交到磁盘并避免大的延迟峰值非常有用。 aof-rewrite-incremental-fsync yes # 当redis保存RDB文件时，如果启用了以下选项，则文件将每生成32 MB数据进行fsync。这对于更多增量地将文件提交到磁盘并避免大的延迟峰值非常有用。 rdb-save-incremental-fsync yes # 可以调优Redis LFU清除(参见maxmemory设置)。 # 但是，最好从默认设置开始，只有在研究了如何改进性能和键LFU如何随时间变化(可以通过OBJECT FREQ命令进行检查)之后才更改它们。 # 在Redis LFU实现中有两个可调参数:计数器对数因子和计数器衰减时间。在更改这两个参数之前，理解它们的含义是很重要的。 # LFU计数器仅为每个键8位，其最大值为255，因此Redis使用具有对数行为的概率增量。 # 给定旧计数器的值，当访问一个键时，计数器按如下方式递增: # 1. 提取0到1之间的随机数R。 # 2. 概率P计算为1/(old_value*lfu_log_factor+1)。 # 3.计数器只有在R 活跃碎片整理（ACTIVE DEFRAGMENTATION） # 警告：此功能是实验性的。然而，即使在生产中，它也进行了压力测试，并由多名工程师手动测试了一段时间。 # 什么是活动碎片整理？ # ------------------------------- # 主动（在线）碎片整理允许Redis服务器压缩内存中数据的小分配和释放之间留下的空间，从而允许回收内存。 # 碎片化是每个分配器（幸运的是Jemalloc）和某些工作负载都会发生的自然过程。通常需要重新启动服务器以降低碎片，或者至少清除所有数据并重新创建。然而，由于Oran Agra for Redis 4.0实现了这一功能，在服务器运行时，这个过程可以在运行时以“热”方式进行。 # 基本上，当碎片超过某个级别时（请参阅下面的配置选项），Redis将通过利用某些特定的Jemalloc特性（以了解分配是否导致碎片并将其分配到更好的位置），开始在连续内存区域中创建值的新副本，同时，释放数据的旧副本。对所有键递增重复此过程将导致碎片降至正常值。 # 需要了解的重要事项： # 1. 默认情况下，此功能是禁用的，只有当您编译Redis以使用我们随Redis源代码提供的Jemalloc副本时，此功能才有效。这是Linux版本的默认设置。 # 2. 如果没有碎片问题，则永远不需要启用此功能。 # 3. 一旦遇到碎片，您可以在需要时使用命令“CONFIG SET activedefrag yes”启用此功能。 # 配置参数能够微调碎片整理过程的行为。如果您不确定它们的含义，那么保持默认值不变是一个好主意。 # 已启用活动碎片整理 # activedefrag yes # 启动活动碎片整理所需的最小碎片浪费量 # active-defrag-ignore-bytes 100mb # 启动活动碎片整理的最小碎片百分比 # active-defrag-threshold-lower 10 # 我们使用最大努力的最大碎片百分比 # active-defrag-threshold-upper 100 # CPU百分比的碎片整理工作量最小 # active-defrag-cycle-min 5 # 最大碎片整理工作量（CPU百分比） # active-defrag-cycle-max 75 # 将从主字典扫描处理的set/hash/zset/list字段的最大数量 # active-defrag-max-scan-fields 1000 Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-02-17 18:28:18 "},"redis/robj/":{"url":"redis/robj/","title":"Redis对象","keywords":"","body":"robj对象 Redis是一个key-value型数据库，key只能是字符串，value可以是字符串、列表、集合、有序集合和哈希，这5种数据类型用结构体robj表示，我们称之为Redis对象。 robj数据结构 typedef struct redisObject { unsigned type:4; // 对象类型（4位=0.5字节） unsigned encoding:4; // 编码（4位=0.5字节） unsigned lru:LRU_BITS; // 记录对象最后一次被应用程序访问的时间（24位=3字节）,LRU时间（相对于全局LRU_clock）或LFU数据（最低有效8位频率和最高有效16位访问时间）。 int refcount; // 引用计数。等于0时表示可以被垃圾回收（4字节） void *ptr; // 数据指针。指向真正的数据(8字节)。比如，一个代表string的robj，它的ptr可能指向一个sds结构；一个代表list的robj，它的ptr可能指向一个quicklist } robj; type字段 encoding字段 #define OBJ_ENCODING_RAW 0 /* Raw representation 原始表示法 */ #define OBJ_ENCODING_INT 1 /* Encoded as integer 整数 */ #define OBJ_ENCODING_HT 2 /* Encoded as hash table 哈希表 */ #define OBJ_ENCODING_ZIPMAP 3 /* Encoded as zipmap 压缩字典，未使用 */ #define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. 不再使用 */ #define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist 压缩列表 */ #define OBJ_ENCODING_INTSET 6 /* Encoded as intset 整数集合 */ #define OBJ_ENCODING_SKIPLIST 7 /* Encoded as skiplist 跳表 */ #define OBJ_ENCODING_EMBSTR 8 /* Embedded sds string encoding 简单动态字符串 */ #define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists 快速链表 */ #define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks 流 */ 类型和编码的关系 为多种数据类型提供一种统一的表示方式。 允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。 支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进而节省内存。 Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-03-12 11:42:04 "},"redis/string/":{"url":"redis/string/","title":"Redis字符串","keywords":"","body":"简介 字符串存储字节序列，包括文本、序列化对象和二进制数组，是redis最基本的key/value类型的数据结构，也是我们最常用的数据结构。通常用于数据缓存、计数器、分布式锁。 常用函数 函数 命令 描述 set set key value [expiration EX seconds/PX milliseconds] [NX/XX] 设置指定 key 的值 get get key 获取指定 key 的值 setnx setnx key value 只有在 key 不存在时设置 key 的值 incr incr key 将 key 中储存的数字值增一 decr decr key 将 key 中储存的数字值减一 incrby incrby key increment 将 key 所储存的值加上给定的增量值 decrby decrby key increment key 所储存的值减去给定的减量值 业务场景 数据缓存 常见功能：高并发场景的数据预热，热点数据缓存（地区列表、活动数据）、共享session等； 常用函数：SET、GET、MSET、MGET 计数器 常见功能：评论数、点赞数、分享数、收藏数、商品的库存数、用户的访问量等； 常用函数：INCR、DECR、INCRBY、DECRBY 分布式锁 常见功能：商品下单、秒杀、扫码抽奖、领取奖励、登录限频等等； 常用函数：SET、SETNX+EXPIRE // 每60秒限制输入5次 $iphone = \"181xxxxx\"; $key = \"login:limit:\" + $phone; $isExists = redis.set($key,1,\"EX\", 60,\"NX\"); if($isExists || redis.incr($key) 长度限制 redis的字符串长度默认最大是512M。 从客户端的缓存区读取内容的时候，会在函数processMultibulkBuffer判断字符串长度是否大于512MB。 在4.0版本之前，这个数字是写死的： 4.0版本之后，是根据redis.conf中的proto-max-bulk-len来限制的，默认是512MB。 编码类型 Redis字符串的编码类型有int、embstr、raw 3种: INT编码结构如下： EMBSTR编码结构如下： RAW编码结构如下： 为什么是44？ redis使用jemalloc内存分配器，且jemalloc会分配8，16，32，64等字节的内存；如果大于64字节，redis会认为是较大的字符，就会采用row类型存储。 创建embstr的函数createEmbeddedStringObject，如下： // 分配连续内存，使用sdshdr8头信息 robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1); sdshdr8的大小为3个字节，加上1个结束符共4个字节；redisObject的大小为16个字节；一个embstr固定的大小为16+3+1 = 20个字节，因此一个最大的embstr字符串为64-20 = 44字节. Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-03-19 21:33:47 "},"redis/sds/":{"url":"redis/sds/","title":"SDS定义","keywords":"","body":"什么是SDS SDS(Simple Dynamic String)简单动态字符串，是char*的别名。 typedef char *sds; Redis是使用C写的，但是并没有使用C传统的字符串作为数据的存储使用，而是使用自己构建的SDS用来表示字符串类型。 在Redis里面，C字符串只会作为字面量（string literal）用在一些无须对字符串的值进行修改的地方，比如打印日志。 Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-03-03 15:50:02 "},"redis/sds/data_struct.html":{"url":"redis/sds/data_struct.html","title":"SDS数据结构","keywords":"","body":"SDS的数据结构 sds是char*的别名，具体的SDS头信息有5种：sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64，结构体的源码如下： // 注意:sdshdr5从未被使用，我们只是直接访问标志字节。 // 然而，这里是为了记录类型为5的SDS字符串的布局。 struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 低3位存储类型，高5位存储长度，长度区间为0~31(2^5-1) */ char buf[]; /* 柔性数组，存放实际内容 */ }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* buf已使用长度，用1个字节存储 */ uint8_t alloc; /* 总长度，用1个字节存储，最大存储的字符长度为32k（2^8-1） */ unsigned char flags; /* 低3位存储类型，高5位预留 */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* buf已使用长度，用2个字节存储 */ uint16_t alloc; /* 总长度，用2个字节存储，最大存储的字符长度为（2^16-1） */ unsigned char flags; /* 低3位存储类型，高5位预留 */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* buf已使用长度，用4个字节存储 */ uint32_t alloc; /* 总长度，用4个字节存储，最大存储的字符长度为（2^32-1） */ unsigned char flags; /* 低3位存储类型，高5位预留 */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* buf已使用长度，用8个字节存储 */ uint64_t alloc; /* 总长度，用8个字节存储，最大存储的字符长度为(2^64-1) */ unsigned char flags; /* 低3位存储类型，高5位预留 */ char buf[]; }; 这5种类型的主要区别就在于，数据结构中的len和alloc占据的大小不同，也就是这个结构体能存储的长度不同。 sds5结构如下： sdshdr8、sdshdr16、sdshdr32和sdshdr64的结构相同，sdshdr16结构如下： 为啥设计成多种header的数据结构？ 就是为了节省内存。 3.2版本之前，sdshdr只有一种数据结构： struct sdshdr { unsigned int len; /* buf已使用长度，4字节 */ unsigned int free; /* buf剩余长度，4字节 */ char buf[]; /* 柔性数组，存放实际内容 */ }; 这种固定的结构，不用判断类型，使用效率很高。这样也有一个弊端，也就是不管字符串有多长，它的头信息固定是8个字节，但是实际的应用中大部分字符串都不会那么长，所以这样也要浪费很多内存。 设计成多种header头信息，可以根据不同字符串的长度，使用不同的header头信息，这样可以提高SDS的效率和灵活性，以及支持不同的存储空间。实际开发过程中，我们大部分字符串不会超过32k，只要使用sdshdr8就行。 Redis是基于内存的，而内存永远都是珍贵的资源，每一个字节都很重要，所以针对不同大小的字符串使用不同的结构，也是为了节省内存资源 flags有哪些值？ // flags参数有0～4五种类型来分别表示SDS的类型 #define SDS_TYPE_5 0 #define SDS_TYPE_8 1 #define SDS_TYPE_16 2 #define SDS_TYPE_32 3 #define SDS_TYPE_64 4 // SDS类型确定：type&SDS_TYPE_MASK #define SDS_TYPE_MASK 7 SDS类型 长度范围 类型值 SDS_TYPE_5 0 ~ 31 0 SDS_TYPE_8 32 ~ 2^8-1 1 SDS_TYPE_16 2^8 ~ 2^16-1 2 SDS_TYPE_32 2^16 ~ 2^32-1 3 SDS_TYPE_64 2^32 ~ 2^64-1 4 SDS为什么不内存对齐？ 为什么需要内存对齐？ (1) 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问，对齐填充可以提高CPU的数据读取效率。 (2) 平台原因：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据。最常见的是如果不按照适合其平台的要求对数据存放进行对齐，会在存取效率上带来损失。 SDS为什么不对齐？ 以sdshdr32为例，修饰前按4字节对齐大小为12(4×3)字节；修饰后按1字节对齐，注意buf是个char类型的柔性数组，地址连续，始终在flags之后。 不采用内存对齐有两个好处： 节省内存，从上面sdshdr32看到可以节省3个字节（12-9）； 能更方便的计算buf的位置，以及取flags的值； SDS创建之后返回的不是结构体首地址,而是指向内容的buf指针，如下图所示： buf指针地址 = (char*)sh+sizeof(sdshdr##T)。flags = buf[-1]。若没有packed的修饰,还需要对不同结构进行处理,实现更复杂。 🌰执行命令：set name lsc： 所以，SDS不采用内存对齐是为了节省空间。尽管不采用内存对齐可能会导致内存访问效率下降，但是在Redis的应用场景下，更高的空间利用率和更快的内存分配速度是更为重要的。 Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-03-09 21:34:56 "},"redis/sds/diff_c.html":{"url":"redis/sds/diff_c.html","title":"SDS与C字符串的区别","keywords":"","body":"SDS与C字符串的区别 获取字符串长度的时间复杂度 SDS获取字符串的长度通过len属性直接返回，代码如下： static inline size_t sdslen(const sds s) { unsigned char flags = s[-1]; switch(flags&SDS_TYPE_MASK) { case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8,s)->len; case SDS_TYPE_16: return SDS_HDR(16,s)->len; case SDS_TYPE_32: return SDS_HDR(32,s)->len; case SDS_TYPE_64: return SDS_HDR(64,s)->len; } return 0; } C字符串通过遍历字符串获取长度，遇到\"\\0\"表示字符串结束，伪代码如下： size_t strlen (const char *str) { const char *char_ptr; unsigned long int longword; for (char_ptr = str; ((unsigned long int) char_ptr& (sizeof (longword) - 1)) != 0; ++char_ptr) if (*char_ptr == '\\0') return char_ptr - str; return 0; } 杜绝缓冲区溢出 像是C的函数strcat、strcpy这些函数容易造成缓冲区溢出。以字符串复制函数strcpy为例，将s2复制给s1，如果s1的长度大于s2的长度的时候能正常运行，否则就会缓冲区溢出报错。 int main(int argc, char * argv[]) { char s1[10] = \"hello\"; char s2[20] = \"This is runoob.com\"; strcpy(s1, s2); printf(\"字符串长度：%lu；字符串： %s\\n\", strlen(s1), s1); return 0; } // 正常：字符串长度：18；字符串： This is runoob.com // 溢出： // Linux环境报错：段错误 // Mac环境报错：/bin/sh: line 1: 81383 Illegal instruction: 4 与C字符串不一样的是，SDS的空间分配策略完全杜绝了缓冲区溢出的可能，在对SDS修改的时候，会先检查SDS的容量alloc是否大于等于新字符串的长度，如果小于新字符串的长度，就会自动扩容，然后执行复制操作，实例如下： int main(int argc, char **argv) { sds s1, s2; s1= sdsnew(\"hello\"); printf(\"s1 = %s; alloc = %zu; len=%zu \\n\", s1, sdsalloc(s1), sdslen(s1)); s2 = sdscpy(s1, \"hello world\"); printf(\"s2 = %s; alloc = %zu; len=%zu \\n\", s2, sdsalloc(s2), sdslen(s2)); return 0; } // 输出 s1 = hello; alloc = 5; len=5 s2 = hello world; alloc = 22; len=11 内存重新分配次数的优化 因为C字符串并不记录自身的长度，所以对于一个包含了 N 个字符的 C 字符串来说，这个 C 字符串的底层实现总是一个 N + 1 个字符长的数组（额外的一个字符空间用于保存空字符）。 因为C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个 C 字符串，程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作： 如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。 如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。 对于未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。 空间预分配策略 采用空间换时间的方式，利用预分配策略，较少频繁分配内存。 惰性空间释放机制 SDS字符串缩短时并不会立即释放多余的空间，只是更新SDS的len属性，多出来的空间供将来使用。比如sdstrim，sdscpy函数。 int main(int argc, char **argv) { s = sdsnew(\"AA...AA.a.aa.aHelloWorld :::\"); printf(\"s = %s; alloc = %zu; len=%zu \\n\", s, sdsalloc(s), sdslen(s)); // s = AA...AA.a.aa.aHelloWorld :::; alloc = 32; len=32 s = sdstrim(s, \"Aa. :\"); printf(\"s = %s; alloc = %zu; len=%zu \\n\", s, sdsalloc(s), sdslen(s)); // s = HelloWorld; alloc = 32; len=10 return 0; } 惰性空间释是否会造成内存泄露？ SDS也提供了真正释放SDS未使用空间的方法sdsRemoveFreeSpace，并不会造成内存的泄露。如果字符串类型是row，并且SDS空闲长度超过10%，就会调用sdsRemoveFreeSpace函数进行空间释放。例如：我们把上面的s多余的空间释放： s = sdsRemoveFreeSpace(s); printf(\"s = %s; alloc = %zu; len=%zu \\n\", s, sdsalloc(s), sdslen(s)); // s = HelloWorld; alloc = 10; len=10 Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-03-12 15:08:36 "},"redis/sds/make_room.html":{"url":"redis/sds/make_room.html","title":"SDS扩容策略","keywords":"","body":"SDS扩容策略 在对SDS进行修改的时候，会先判断容量是否够用，不够用就自动扩容（sdsMakeRoomFor）。 查看源码 扩容流程如下： 如果SDS中剩余空间(avail)大于新增内容的长度(addlen)，则无需扩容； 如果SDS中剩余空间(avail)小于等于新增内容的长度(addlen)： 若新增后总长度 len+addlen 若新增后总长度 len+addlen > 1MB，则按新长度加上 1MB 扩容。 空间预分配策略：SDS扩容会多分配了一些空间，减少修改字符串时带来的内存重分配次数； 🌰执行append命令如下： 127.0.0.1:6379> set name lsc OK 127.0.0.1:6379> get name \"lsc\" (63.83s) 127.0.0.1:6379> append name lsc (integer) 6 127.0.0.1:6379> get name \"lsclsc\" GDB调试如下： Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-03-11 22:11:49 "},"redis/sds/source_code.html":{"url":"redis/sds/source_code.html","title":"SDS函数","keywords":"","body":"sdsnewlen sds sdsnewlen(const void *init, size_t initlen) { void *sh; sds s; // SDS类型 char type = sdsReqType(initlen); // 空字符串设置为sdshdr8 if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8; int hdrlen = sdsHdrSize(type); // 指向flags的指针 unsigned char *fp; /* flags pointer. */ // 分配内存 sh = s_malloc(hdrlen+initlen+1); if (init==SDS_NOINIT) init = NULL; else if (!init) memset(sh, 0, hdrlen+initlen+1); if (sh == NULL) return NULL; // 将指针指向buf的位置 s = (char*)sh+hdrlen; // 设置flags fp = ((unsigned char*)s)-1; // 根据type设置成不同的header switch(type) { case SDS_TYPE_5: { *fp = type | (initlen len = initlen; sh->alloc = initlen; *fp = type; break; } case SDS_TYPE_16: { SDS_HDR_VAR(16,s); sh->len = initlen; sh->alloc = initlen; *fp = type; break; } case SDS_TYPE_32: { SDS_HDR_VAR(32,s); sh->len = initlen; sh->alloc = initlen; *fp = type; break; } case SDS_TYPE_64: { SDS_HDR_VAR(64,s); sh->len = initlen; sh->alloc = initlen; *fp = type; break; } } // 内存拷贝 if (initlen && init) memcpy(s, init, initlen); // sds最后添加\\0，为了能兼容c字符串 s[initlen] = '\\0'; return s; } sdscpy sds sdscpylen(sds s, const char *t, size_t len) { // 现有容量是否小于新字符串长度 if (sdsalloc(s) sdsMakeRoomFor sds sdsMakeRoomFor(sds s, size_t addlen) { void *sh, *newsh; // 计算s的剩余空间长度：alloc-len size_t avail = sdsavail(s); size_t len, newlen; char type, oldtype = s[-1] & SDS_TYPE_MASK; int hdrlen; // 如果剩余空间足够用，就不用扩容，直接返回s if (avail >= addlen) return s; // SDS的长度 len = sdslen(s); // 获取SDS的首地址 sh = (char*)s-sdsHdrSize(oldtype); // 计算SDS新的长度： // 1、如果新的长度小于1MB，则按新长度的两倍扩容； // 2、如果新的长度大于1MB，则按新长度再加上1MB扩容； newlen = (len+addlen); if (newlen sdsRemoveFreeSpace sds sdsRemoveFreeSpace(sds s) { void *sh, *newsh; // sds类型 char type, oldtype = s[-1] & SDS_TYPE_MASK; // sds类型头长度 int hdrlen, oldhdrlen = sdsHdrSize(oldtype); size_t len = sdslen(s); size_t avail = sdsavail(s); // sds首地址(len属性地址) sh = (char*)s-oldhdrlen; // 如果没有空闲的空间，不需要变动 if (avail == 0) return s; // 根据sds现在的长度，重新计算sds类型以及类型大小 type = sdsReqType(len); hdrlen = sdsHdrSize(type); // 如果新长度的类型和之前类型一样，只需要调整原来字符串的大小即可； // 如果新长度的类型和之前类型不一样，由于sds头信息大小更改，需要重新分配内存； if (oldtype==type || type > SDS_TYPE_8) { // 调整字符串sh的大小 newsh = s_realloc(sh, oldhdrlen+len+1); if (newsh == NULL) return NULL; s = (char*)newsh+oldhdrlen; } else { // 由于sds头信息大小更改，需要向前移动字符串，并且不能使用realloc newsh = s_malloc(hdrlen+len+1); if (newsh == NULL) return NULL; // 将原字符串拷贝到新的地址 memcpy((char*)newsh+hdrlen, s, len+1); // 释放老的内存 s_free(sh); // 设置SDS的新类型以及长度 s = (char*)newsh+hdrlen; s[-1] = type; sdssetlen(s, len); } // 设置SDS的总长度alloc sdssetalloc(s, len); return s; } Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-03-11 14:20:23 "},"redis/gdb/":{"url":"redis/gdb/","title":"GDB使用","keywords":"","body":"查看内存地址保存的值 可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示: (gdb) x/nfu addr n 表示需要显示的内存单元个数，也就是从当前地址向后显示几个内存单元的内容，一个内存单元的大小由后面的u定义。 f 表示显示的格式 x(hex) 按十六进制格式显示变量。 d(decimal) 按十进制格式显示变量。 u(unsigned decimal) 按十进制格式显示无符号整型。 o(octal) 按八进制格式显示变量。 t(binary) 按二进制格式显示变量。 a(address) 按十六进制格式显示变量。 c(char) 按字符格式显示变量。 f(float) 按浮点数格式显示变量 u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可 以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当 我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作 一个值取出来。 addr表示一个内存地址。 n/f/u三个参数可以一起使用。例如： (gdb) x/3uh 0x54320 //从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十进制显示。 打印数组 命令 作用 p *array@10 打印从数组开头连续10个元素的值 p array[60]@10 打印第60～69个元素 set print array-indexes on 打印数组元素时，同时打印数组下标 (float )(addr)@num 打印地址值 将addr转换成float*类型，并打印num个值 打印指针/结构体 命令 作用 print ptr 查看该指针指向的类型及指针地址 print (struct xxx )ptr 查看指向的结构体内容 处理C预处理器宏 命令 作用 macro define 定义新的C/C++预处理器宏 macro expand 完全扩展EXPRESS中的任何C/C++预处理器宏调用 macro expand-once 扩展直接出现在表达式中的C/C++预处理器宏调用 macro list 列出使用“宏定义”命令定义的所有宏 macro undef 删除具有给定名称的C/C++预处理器宏的定义 使用gdb调试redis的sdshdr宏 (gdb) macro define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) (gdb) macro list macro define SDS_HDR(T, s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) (gdb) p SDS_HDR(8,$2) $22 = (struct sdshdr8 *) 0x7ffff6c29930 (gdb) p *SDS_HDR(8,$2) $23 = {len = 3 '\\003', alloc = 3 '\\003', flags = 1 '\\001', buf = 0x7ffff6c29933 \"lsc\"} (gdb) macro undef SDS_HDR (gdb) macro list (gdb) 设置打印格式 命令 作用 set print pretty on 每行只显示结构体的一名成员 set print null-stop 不显示'\\000\\' TUI模式 进入TUI模式 快捷键 作用 Ctrl + X + A 进入（退出）TUI模式 四个窗口 命令 作用 command(cmd) 命令窗口，可以输入调试命令 source(src) 源代码窗口， 显示当前行、断点等信息 assembly(asm) 汇编代码窗口 register(reg) 寄存器窗口 split 源码和汇编混合窗口 窗口切换 1、 可以使用layout + 窗口类型命令来显示相应的窗口，例如显示寄存器窗口layout reg: 2、 使用focus命令切换激活的窗口,可简写为fs 命令 作用 focus src(fs s) 源码窗口 focus cmd(fs c) 命令窗口 focus asm(fs a) 汇编窗口 focus reg(fs r) 寄存器窗 focus next(fs n) 下一窗口 focus prev(fs p) 上一窗口 3、使用TUI快捷键 快捷键 作用 Ctrl + X + 1 使TUI只显示一个窗口 Ctrl + X + 2 使TUI显示两个窗口，连续使用该快捷键可在三种窗口之间切换（但同时只能显示两个窗口） Ctrl + X + o 切换激活窗口，效果类似focus Ctrl + X + s 在TUI模式和TUISingleKey模式之间切换，没啥用 刷新屏幕 快捷键或者命令 作用 Ctrl + L 刷新窗口 refresh命令 刷新窗口 update命令 刷新源码窗至当前执行点 窗口属性 窗口大小使用winheight调节,单位：行数 ##将代码窗口的高度扩大 5 行代码 winheight src + 5 ##将代码窗口的高度减小 4 代码 winheight src - 4 断点状态显示 在tui模式下，能够显示程序执行的状态和断点状态 B表示该断点已执行 b表示该断点未执行 +表示断点使能 -表示断点失能 其它快捷键 快捷键 作用 Ctrl + p 上一命令行 Ctrl + n 下一命令行 Ctrl + b 命令行光标前移 Ctrl + f 命令行光标后移 Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-02-22 11:34:18 "},"redis/question/":{"url":"redis/question/","title":"常见问题","keywords":"","body":"缓存问题 问题 说明 行为 解决方案 缓存穿透 大量请求根本不存在的key 缓存穿透一般是黑客攻击所为，黑客通过发送大量无效的请求给服务器，由于请求的资源根本就不存在，Redis查询不到数据，会一直查询DB，DB就很容易被打垮。 1、非法请求的限制；主要是指参数校验、鉴权校验等，从而一开始就把大量的非法请求拦截在外，这在实际业务开发中是必要的手段；2、对不存在的数据进行缓存；如果数据不存在，返回空，不再请求数据库，但是对方如果一直使用动态不重复的数据请求，这个也是无效的。3、使用布隆过滤器；Redis使用BitMap实现布隆过滤器，将目前所有可以访问到的资源通过多种哈希算法映射到到布隆过滤器中，当一个请求来临的时候先进行布隆过滤器的判断，如果有那么才进行放行，否则就直接拦截。但是布隆过滤器也可能出现哈希冲突，布隆过滤器的特点：不存在的一定不存在，存在的不一定存在。 缓存雪崩 redis中大量的key集体过期 缓存雪崩一般是redis大量的key设置的过期时间一样，大量的key同时过期，一段时间内本应在redis缓存中处理的大量请求，都发送到了数据库进行处理，导致对数据库的压力迅速增大，可能导致数据库崩溃，从而导致整个系统崩溃，就像雪崩一样，引发连锁效应，所以叫缓存雪崩。 1、将过期时间分散；在过期时间上添加随机数，避免缓存集体过期。2、使用锁机制；如果Redis查不到就加上排它锁，其他请求只能进行等待，使重新构建缓存的操作不会在同一时间进行。3、使用多级缓存；redis缓存+其他缓存，不同层使用不同的缓存，可靠性更强。4、缓存降级；直接访问内存部分的数据缓存；直接返回系统设置的默认值。5、后台更新缓存策略；采用定时任务或者消息队列的方式进行redis缓存更新或移除等。 缓存击穿 redis中的某个热点key过期，但是此时有大量的用户访问该过期key 缓存击穿一般出现在高并发系统中，是大量并发用户同时请求到缓存中没有但数据库中有的数据，也就是同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 1、不设置过期时间；对热点数据不设置过期时间。2、使用锁机制；如果Redis查不到就加上排它锁，其他请求只能进行等待，使重新构建缓存的操作不会在同一时间进行。 Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-01-31 16:43:20 "}}