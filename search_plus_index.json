{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2022-11-22 11:22:06 "},"redis/config/":{"url":"redis/config/","title":"配置文件","keywords":"","body":"配置文件的单位说明 关于单位的说明：当需要内存大小时，可以以1k 5GB 4M等通常形式指定： 1k=>1000字节 1kb=>1024字节 1m=>1000000字节 1mb=>1024*1024字节 1g=>1000000000字节 1gb=>1024*1024*1024字节 单位不区分大小写，因此1GB 1Gb 1gB都相同。 引入其它配置（INCLUDES） # 包含其他配置文件，将redis的配置分离管理时使用 # include /path/to/local.conf # include /path/to/other.conf 模块（MODULES） # 引入自定义模块来新增一些功能。 # loadmodule /path/to/my_module.so # loadmodule /path/to/other_module.so 网络配置（NETWORK） 网络监听 使用bind指令指定监听的IP，默认情况下，如果未指定“bind”配置指令，Redis将侦听服务器上所有可用网络接口的连接。 bind 127.0.0.1 可以使用“bind”配置指令，后跟一个或多个IP地址。 # bind 192.168.1.100 10.0.0.1 # bind 127.0.0.1 ::1 监听端口 接受指定端口上的连接，默认值为6379，如果指定端口0，Redis将不会侦听TCP套接字。 port 6379 保护模式 保护模式是一层安全保护，以避免在互联网上打开的Redis实例被访问和利用，默认是开启状态 protected-mode yes TCP队列长度 在linux系统中控制tcp三次握手已完成连接队列的长度。 在高并发系统中，你需要设置一个较高的tcp-backlog来避免客户端连接速度慢的问题（三次握手的速度) tcp-backlog 511 注意事项： 1、已完成连接队列的长度也与操作系统中/proc/sys/net/core/somaxconn有关，取二者最小min(tcp-backlog,somaxconn) // linux查看已完成连接队列的长度 $ /proc/sys/net/core/somaxconn //mac查看已完成连接队列的长度 $ sysctl -a|grep somaxconn 2、已完成连接队列又与半连接队列长度有关 // linux查看半连接队列长度 $ /proc/sys/net/ipv4/tcp_max_syn_backlog //mac查看半连接队列长度 $ sysctl -a|grep backlog 3、简要介绍下半连接与已完成连接 半连接：服务端收到客户端syn后,将连接放入半连接队列。如果半连接队列已满会丢弃，客户端报错connection time out。 已完成连接：服务端收到客户端的ack后，从半连接队列中拿出连接放入已完成连接队列。如果已完成连接队列已经满则无法放入，客户端报错read timeout或者connection reset by peer 超时时间 客户端空闲N秒后关闭连接（0表示禁用） timeout 0 长链接 如果非零，则使用SO_KEEPALIVE在没有通信的情况下向客户端发送TCP ACK。这有两个原因： 检测死对等体。 从在中间网络设备的角度来看，连接是活的。 在Linux上，指定的值（以秒为单位）是用于发送ACK的时间段。 请注意，要关闭连接，需要双倍的时间。 在其他内核上，周期取决于内核配置。 此选项的合理值为300秒，这是从Redis 3.2.1开始的新Redis默认值。 tcp-keepalive 300 常规配置（GENERAL） # 默认情况下，Redis不作为守护程序运行。如果需要，请使用`yes`，当守护进程化时，Redis将在/var/run/Redis.pid中写入一个pid文件。 daemonize no # 若从upstart或systemd运行Redis，则Redis可以与监控树交互。 #+ supervised no -无相互监督 #+ supervised upstart - 使Redis进入SIGSTOP模式并监控upstart #+ supervised systemd - 通过设置READY=1到$NOTIFY_SOCKET来监控systemd #+ supervised auto - 基于UPSTART_JOB或NOTIFY_SOCKET环境变量的监督自动检测upstart或systemd方法 supervised no # 配置PID文件路径，当redis以守护进程运行时，它会将pid默认写到/var/run/redis_6379.pid文件中 pidfile /var/run/redis_6379.pid # 日志级别(debug/verbose/notice/warning)，默认为notice loglevel notice # 指定日志文件名。空字符串也可以用于强制Redis登录标准输出。注意，如果您使用标准输出进行日志记录，但使用后台进程，则日志将被发送到/dev/null logfile \"\" # 系统日志设置，要启用系统日志记录，只需将`syslog enabled`设置为`yes`，默认为no # syslog-enabled no # 指定syslog标识。 # syslog-ident redis # 指定syslog工具。必须是USER或介于LOCAL0-LOCAL7之间。 # syslog-facility local0 # 设置数据库数量 databases 16 # 默认logo标识只在交互回话中显示。 # 该设置可以设置始终在启动日志中显示ASCII art徽标。 always-show-logo yes 快照设置（SNAPSHOTTING） # 指定多长时间内(秒)，有多少次更新操作，就将数据同步到磁盘，可以多条件配合 # save # save \"\" 可以设置为空完全禁用保存 save 900 1 # 900s内至少有1次更新操作则保存 save 300 10 # 300s内至少有10次更新操作则保存 save 60 10000 # 60s内至少有10000次更新操作则保存 # 当启用RDB最后一次后台保存数据失败，redis停止接受数据，以通知用户数据没有正确持久化到磁盘中。 stop-writes-on-bgsave-error yes # 指定存储至本地数据库时是否压缩数据，默认为yes。关闭压缩会节省CPU时间，但会导致数据文件变大 rdbcompression yes # 存储快照后，让redis使用CRC64算法进行数据校验，但是增大了性能消耗，在保存和加载RDB文件时约10%性能消耗。 rdbchecksum yes # 指定rdb文件名 dbfilename dump.rdb # 指定本地数据库存放位置 dir ./ 主从复制（REPLICATION） # 用replicaof使Redis实例成为另一个Redis服务器的副本 replicaof # 当master服务设置了密码保护是，slave服务连接master的密码 masterauth #当一个slav和一个master是去联系或在进行复制时，slave是否进行响应。 # yes：Slave扔会应答请求，但返回数据可能已过时，或者数据为空 # no：在执行info he slaveof 之外的命令时，slave将返回一个\"SYNC with master in progress\" slave-serve-stale-data yes # slave是否只读 slave-read-only yes # 主从数据复制是否使用无硬盘复制功能 repl-diskless-sync no # 当启用无盘复制时，可以配置服务器等待的延迟，以便生成通过套接字将RDB传输到副本的子级。 # 这一点很重要，因为一旦传输开始，就不可能为到达的新副本提供服务，这些副本将排队等待下# 延迟以秒为单位指定，默认情况下为5秒。要完全禁用它，只需将其设置为0秒，传输将尽快开始。 repl-diskless-sync-delay 5 # 从服务器以预定义的时间间隔向服务器发送ping信号。默认值是10秒。 # repl-ping-slave-period 10 # 以下选项设置的复制超时： #1）从副本的角度来看，SYNC期间的批量传输I/O。 #2）从副本（数据、ping）的角度来看，主超时。 #3）从主机的角度来看，副本超时（REPLCONF ACK ping）。 # 务必确保该值大于repl-ping-replica-period的值，否则每次主服务器和复制副本之间的通信量低时都会检测到超时。 # repl-timeout 60 # 在SYNC之后禁用复制套接字上的TCP_NODELAY？ # 如果选择“yes”，Redis将使用更少的TCP数据包和更少的带宽向副本发送数据。但这可能会增加数据出现在副本端的延迟，对于使用默认配置的Linux内核，延迟可达40毫秒。 # 如果选择“no”，数据出现在副本侧的延迟将减少，但复制将使用更多的带宽。 # 默认情况下，我们针对低延迟进行优化，但在非常高的流量条件下，或者当主服务器和副本相隔很远时，将此设置为“是”可能是一个好主意。 repl-disable-tcp-nodelay no # 设置复制积压工作的大小。backlog是一个缓冲区，当副本断开连接一段时间时，它会累积副本数据，因此当副本想要再次连接时，通常不需要完全重新同步，但部分重新同步就足够了，只需传递断开连接时副本丢失的部分数据。 # 复制积压越大，复制副本断开连接的时间就越长，以后可以执行部分重新同步。 # 只有在至少连接了一个副本时，才会分配积压工作。 # repl-backlog-size 1mb # 主服务器在一段时间内(从上一个副本断开连接开始)不再连接副本后，将backlog被释放。 # 注意，副本永远不会释放backlog以等待超时，因为它们可能会在以后升级为主副本，并且应该能够正确地与副本“部分重新同步”：因此它们应该始终累积backlog。 # 值为0表示从不释放backlog。 # repl-backlog-ttl 3600 #slave节点的优先级，低优先的slave节点更容易被提升为master节点 # 优先级为0，则该slave节点不能被提升为master节点 slave-priority 100 # 如果连接的副本少于N个，且延迟小于或等于M秒，则主机可以停止接受写入。 # N个副本需要处于“在线”状态。 # 延迟（以秒为单位，必须 安全（SECURITY） # 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时 # 需要通过AUTH 命令提供密码，默认关闭 # requirepass foobared # 重新命名命令，例如：rename-command command1 newName # 也可以禁用某个命令，例如禁用config命令：rename-command CONFIG \"\" # 请注意，更改记录到AOF文件或传输到副本的命令的名称可能会导致问题 # rename-command command1 newName 客户端（CLIENTS） # 允许最大客户端连接数 maxclients 10000 内存管理（MEMORY MANAGEMENT） # 限制Redis最大内存（单位：bytes） # 当达到内存限制时，Redis将尝试根据maxmemory-policy设置的淘汰策略进行内存优化 # 如果Redis无法根据策略删除密钥，或者如果策略设置为“noevision”，则Redis将开始对使用更多内存的命令（如set、LPUSH等）进行错误回复，并继续对GET等只读命令进行回复。 # 当使用Redis作为LRU或LFU缓存，或为实例设置硬内存限制（使用“noevision”策略）时，此选项通常很有用。 # 警告：如果您将副本附加到启用了maxmemory的实例，则从已用内存计数中减去馈送副本所需的输出缓冲区的大小，这样网络问题/重新同步将不会触发密钥被逐出的循环，进而副本的输出缓冲池已满，被逐出的密钥的DEL将触发更多密钥的删除，等等，直到数据库被完全清空。 # 简而言之。。。如果附加了副本，建议您设置maxmemory的下限，以便系统上有一些可用的RAM用于副本输出缓冲区（但如果策略为“noevision”，则不需要这样做）。 # maxmemory # 内存淘汰策略 # volatile-lru -> 使用LRU算法移除key，只针对设置了过期时间的key. # allkeys-lru -> 使用LRU算法移除key，对所有key. # volatile-lfu -> 使用LFU算法移除key，只针对设置了过期时间的key. # allkeys-lfu -> 使用LFU算法移除key，对所有key. # volatile-random -> 在过期集合中随之移除key，只对设置了过期时间的key # allkeys-random -> 在过期集合中随之移除key，对所有key. # volatile-ttl -> 移除那些TTL最小的key，即最近要过期的key # noeviction -> 永不过期，内存满时直接报错（默认值） # LRU表示最近最少使用 # LFU表示最不常用 # maxmemory-policy noeviction # 设置检验样本数 # LRU、LFU和最小TTL算法不是精确算法，而是近似算法（为了节省内存），因此您可以调整其速度或精度。默认情况下，Redis将检查五个键并选择最近使用较少的键，您可以使用以下配置指令更改样本大小。 # 默认值为5会产生足够好的结果。10非常接近真实的LRU，但需要更多的CPU。3的速度更快，但不是很准确。 # maxmemory-samples 5 # 从服务是否忽略最大内存限制 # 从Redis 5开始，默认情况下，副本将忽略其最大内存设置（除非在故障切换后或手动将其升级为主副本）。这意味着淘汰key的操作将只由主机处理，当密钥在主机端逐出时，向副本发送DEL命令。 # replica-ignore-maxmemory yes 惰性释放（LAZY FREEING） # 对不同数据的删除策略，设置是否阻塞 # Redis删除数据FLUSHALL和FLUSHDB的DEL、UNLINK和ASYNC选项由用户控制，且默认都是阻塞的。 lazyfree-lazy-eviction no lazyfree-lazy-expire no lazyfree-lazy-server-del no slave-lazy-flush no 数据文件记录模式（APPEND ONLY MODE） # 是否每次更新后进行日志记录。Redis默认异步将数据写入磁盘，数据在一段时间内只存在于内存中。 appendonly no # 指定更新日志文件名 appendfilename \"appendonly.aof\" #指定更新日志条件 # no表示等操作系统进行数据缓存同步到磁盘（快） # always 表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） # everysec 每秒同步一次（折中，默认值） appendfsync everysec # 设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。 # Linux的默认fsync策略是30秒。可能丢失30秒数据. no-appendfsync-on-rewrite no # 当AOF日志大小增长指定的百分比时，Redis能够自动调用BGREWRITEEAOF命令对日志文件重写。 # 工作原理：Redis会记住最近一次重写后AOF文件的大小（如果重新启动后没有发生重写，则使用启动时AOF的大小）。 # 将此基本尺寸与当前尺寸进行比较。如果当前大小大于指定的百分比，将触发重写。此外，您需要指定要重写的AOF文件的最小大小，这对于避免重写AOF文件非常有用，即使达到了百分比增加，但仍然非常小。 # 指定零的百分比以禁用自动AOF重写功能。 auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb # 在Redis启动过程中，当AOF数据加载回内存时，可能会发现AOF文件在最后被截断。 # 当运行Redis的系统崩溃时，可能会发生这种情况，特别是在安装ext4文件系统时没有data=ordered选项（但是，当Redis本身崩溃或中止但操作系统仍正常工作时，这种情况不会发生）。 # 当发生这种情况时，Redis可以退出并返回错误，或者加载尽可能多的数据（现在是默认值），如果发现AOF文件在结尾处被截断，则重新启动。以下选项控制此行为： # 如果aof-load-truncated设置为yes，则会加载一个被截断的aof文件，并且Redis服务器会开始发出日志通知用户该事件。 # 如果aof-load-truncated置为no，服务器将因错误而中止并拒绝启动。用户需要在重新启动服务器之前使用“redis-check-aof”修复AOF文件。 #请注意，如果发现AOF文件在中间损坏，服务器仍将退出并返回错误。只有当Redis尝试从AOF文件中读取更多数据，但找不到足够的字节时，此选项才适用。 aof-load-truncated yes # 是否开启混合持久化 # 开启后，当重写AOF文件时，Redis能够在AOF文件中使用RDB前导码，以便更快地进行重写和恢复。 # 启用此选项后，重写的AOF文件由两个不同的节组成：[RDB file][AOF tail] # 当加载Redis识别到AOF文件以“Redis”字符串开头，并加载带有前缀的RDB文件，然后继续加载AOF尾部 aof-use-rdb-preamble yes LUA脚本（LUA SCRIPTING） # Lua脚本的最大执行时间（毫秒） lua-time-limit 5000 Redis集群（REDIS CLUSTER） #是否开启集群，默认不开启 # cluster-enabled yes # 集群配置文件名称。每个节点都有一个单独的集群相关的配置文件，持久化保存集群信息。 # 这个文件不需要手动配置，由redis自动生成并更新。 # 名称不能重复 # cluster-config-file nodes-6379.conf # 节点之间互联超时的阀值，ms # cluster-node-timeout 15000 #用于判断slave节点和master断开的时间阀值，超过该值slave节点不能申请成为master节点。 # cluster-slave-validity-factor 10 # master的slave数大于该值，slave则能迁移到其他孤立的master上 # cluster-migration-barrier 1 # 默认情况下，如果Redis群集节点检测到至少有一个哈希槽未覆盖（没有可用节点为其提供服务），则会停止接受查询。 # 这样，如果集群部分关闭（例如，不再覆盖一系列哈希槽），则所有集群最终都将不可用。一旦再次覆盖所有插槽，它就会自动返回可用状态。 # 然而，有时您希望正在工作的集群的子集继续接受对仍然覆盖的部分密钥空间的查询。为此，只需将集群cluster-require-full-coverage选项设置为no。 # cluster-require-full-coverage yes # 设置是否进行故障转移，如果设置为yes，则将阻止master故障时进行故障转移，但仍可以手动强制进行故障转移；（在一些特定场景下可能用得到） # cluster-replica-no-failover no 集群总线/NAT设置（CLUSTER DOCKER/NAT support） # 在某些部署中，Redis集群节点地址发现失败，因为地址是NAT-ted的或者因为端口被转发(典型的情况是Docker和其他容器)。 # 为了让Redis集群在这样的环境中工作，需要一个静态配置，指定节点的公共地址 。 # 每个节点都指示节点的地址、客户端端口和集群消息总线端口，然后将信息发布到总线包的头部，以便其他节点能够正确映射发布信息的节点的地址。 # # cluster-announce-ip 10.1.1.5 # cluster-announce-port 6379 # cluster-announce-bus-port 6380 慢日志（SLOW LOG） # 要超过多少执行时间（以微秒为单位，1000000相当于1秒）才能记录命令。请注意，负数将禁用慢速日志，而值为零将强制记录每个命令。 slowlog-log-slower-than 10000 # 慢日志的长度，此长度没有限制。只需注意它会消耗内存。 # 可以使用SLOWLOG RESET回收慢速日志使用的内存。 slowlog-max-len 128 监控延迟命令（LATENCY MONITOR） # Redis延迟监视子系统在运行时采样不同的操作，以便收集与Redis实例的潜在延迟源相关的数据。 # 通过LATENCY命令，可以将此信息提供给能够打印图形和获取报告的用户。 # 系统只记录在等于或大于通过延迟监视阀值配置指令指定的毫秒数的时间内执行的操作。 # 当它的值被设置为零时，延迟监视器将被关闭。 # 如果需要，可以在运行时使用“CONFIG SET latency-monitor-threshold >”命令轻松启用延迟监视。 latency-monitor-threshold 0 事件通知（EVENT NOTIFICATION） # Redis可以将密钥空间中发生的事件通知发布/订阅客户端。这个特性记录在http://redis.io/topics/notifications # 如果启用了keyspace事件通知，并且客户端对存储在数据库0中的key \"foo\"执行DEL操作，则两条消息将通过Pub/Sub发布: # 默认情况下，所有通知都是禁用的 notify-keyspace-events \"\" 高级设置（ADVANCED CONFIG） # 指定在超过一定的数量或最大元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-ziplist-entries 512 hash-max-ziplist-value 64 # 列表还以一种特殊的方式进行编码，以节省大量空间。 # 每个内部列表节点允许的条目数可以指定为固定的最大大小或最大元素数。 # 对于固定的最大大小，使用-5到-1，表示： # -5：最大大小：64 Kb节点- >节点- >…- >节点- >(尾巴) # [头]、[尾]永远不会被压缩;内部节点将被压缩。 # 2:[头]- >[下]- >节点- >节点- >…- >节点- >[上一页]- >(尾巴) # 这里的意思是:不要压缩head或head->next或tail->prev或tail，而是压缩它们之间的所有节点。 # 3:[头]- >[下]- >[下]- >节点- >节点- >…- >节点- >[上一页]- >[上一页]- >(尾巴) list-compress-depth 0 # 还有这样一种特殊编码的情况：数据全是64位无符号整型数字构成的字符串。 # 下面这个配置项就是用来限制这种情况下使用这种编码的最大上限的。 set-max-intset-entries 512 #与哈希和列表类似，排序集也经过特殊编码，以节省大量空间。此编码仅在排序集的长度和元素低于以下限制时使用： zset-max-ziplist-entries 128 zset-max-ziplist-value 64 # HyperLogLog稀疏表示字节限制。限制包括16个字节的头。 # 当使用稀疏表示的HyperLogLog超过此限制时，它将被转换为稠密表示。 # 大于16000的值是完全无用的，因为此时密集表示更有效。 # 建议值为0~ 3000，以在不降低太多PFADD(稀疏编码的O(N))的情况下，获得空间高效编码的优点。 # 如果不关心CPU，但关心空间，并且数据集由许多基数在0 - 15000范围内的超loglog组成，则可以将该值提高到~ 10000。 hll-sparse-max-bytes 3000 # 流宏节点最大大小/条目。 # 流数据结构是一个大节点的基数树，在其中编码多个项。使用此配置，可以配置单个节点的大小（以字节为单位），以及在附加新流条目时切换到新节点之前可能包含的最大项目数。如果以下任何设置设置为零，则该限制将被忽略，因此例如，可以通过将最大字节设置为0并将最大条目设置为所需值来仅设置最大整数限制。 stream-node-max-bytes 4096 stream-node-max-entries 100 # 是否激活重置哈希，默认开启 activerehashing yes # 客户端输出缓存限制强迫断开读取速度比较慢的客户端 # client-output-buffer-limit # 当达到强制限制缓存大小，立即断开连接；达到软性限制，仍会有软性时间大小的链接时间 # 默认正常客户端无限制，只有请求后，异步客户端数据请求速度快于它能读取数据的速度 # 订阅模式和主从客户端又默认限制，因为它们都接受推送。 # 强制限制和软性限制都可以设置为0来禁用这个特性 client-output-buffer-limit normal 0 0 0 #正常的客户端包括监控客户端 client-output-buffer-limit slave 256mb 64mb 60 #从客户端 client-output-buffer-limit pubsub 32mb 8mb 60 #客户端至少订阅了一个频道或者模式 # 客户端查询缓冲区累积新命令。默认情况下，它们被限制为固定数量，以避免协议不同步（例如，由于客户端中的错误）将导致查询缓冲区中的未绑定内存使用。但是，如果您有非常特殊的需求，例如巨大的multi/exec请求或类似请求，您可以在这里配置它。 client-query-buffer-limit 1gb # 在Redis协议中，批量请求（即表示单个字符串的元素）通常限制为512 mb # proto-max-bulk-len 512mb # 设置redis任务执行频率，如清除过期键任务、关闭超时链接的客户端 # 范围1-500，值越大CPU消耗越大，建议不超过100 hz 10 # 通常，具有与连接的客户端数量成比例的HZ值是有用的。例如，为了避免每次后台任务调用处理过多的客户端，以避免延迟峰值，这非常有用。 # 由于默认的HZ值保守地设置为10，Redis提供并在默认情况下启用了使用自适应HZ值的能力，当有许多连接的客户端时，该值将临时升高。 # 当启用动态HZ时，实际配置的HZ将用作基线，但一旦连接了更多客户端，则实际使用配置HZ值的倍数。这样，空闲实例将占用很少的CPU时间，而繁忙实例将更具响应性。 dynamic-hz yes # 当子进程重写AOF文件时，如果启用了以下选项，则该文件将每生成32 MB数据进行一次fsync。这对于更多增量地将文件提交到磁盘并避免大的延迟峰值非常有用。 aof-rewrite-incremental-fsync yes # 当redis保存RDB文件时，如果启用了以下选项，则文件将每生成32 MB数据进行fsync。这对于更多增量地将文件提交到磁盘并避免大的延迟峰值非常有用。 rdb-save-incremental-fsync yes # 可以调优Redis LFU清除(参见maxmemory设置)。 # 但是，最好从默认设置开始，只有在研究了如何改进性能和键LFU如何随时间变化(可以通过OBJECT FREQ命令进行检查)之后才更改它们。 # 在Redis LFU实现中有两个可调参数:计数器对数因子和计数器衰减时间。在更改这两个参数之前，理解它们的含义是很重要的。 # LFU计数器仅为每个键8位，其最大值为255，因此Redis使用具有对数行为的概率增量。 # 给定旧计数器的值，当访问一个键时，计数器按如下方式递增: # 1. 提取0到1之间的随机数R。 # 2. 概率P计算为1/(old_value*lfu_log_factor+1)。 # 3.计数器只有在R 活跃碎片整理（ACTIVE DEFRAGMENTATION） # 警告：此功能是实验性的。然而，即使在生产中，它也进行了压力测试，并由多名工程师手动测试了一段时间。 # 什么是活动碎片整理？ # ------------------------------- # 主动（在线）碎片整理允许Redis服务器压缩内存中数据的小分配和释放之间留下的空间，从而允许回收内存。 # 碎片化是每个分配器（幸运的是Jemalloc）和某些工作负载都会发生的自然过程。通常需要重新启动服务器以降低碎片，或者至少清除所有数据并重新创建。然而，由于Oran Agra for Redis 4.0实现了这一功能，在服务器运行时，这个过程可以在运行时以“热”方式进行。 # 基本上，当碎片超过某个级别时（请参阅下面的配置选项），Redis将通过利用某些特定的Jemalloc特性（以了解分配是否导致碎片并将其分配到更好的位置），开始在连续内存区域中创建值的新副本，同时，释放数据的旧副本。对所有键递增重复此过程将导致碎片降至正常值。 # 需要了解的重要事项： # 1. 默认情况下，此功能是禁用的，只有当您编译Redis以使用我们随Redis源代码提供的Jemalloc副本时，此功能才有效。这是Linux版本的默认设置。 # 2. 如果没有碎片问题，则永远不需要启用此功能。 # 3. 一旦遇到碎片，您可以在需要时使用命令“CONFIG SET activedefrag yes”启用此功能。 # 配置参数能够微调碎片整理过程的行为。如果您不确定它们的含义，那么保持默认值不变是一个好主意。 # 已启用活动碎片整理 # activedefrag yes # 启动活动碎片整理所需的最小碎片浪费量 # active-defrag-ignore-bytes 100mb # 启动活动碎片整理的最小碎片百分比 # active-defrag-threshold-lower 10 # 我们使用最大努力的最大碎片百分比 # active-defrag-threshold-upper 100 # CPU百分比的碎片整理工作量最小 # active-defrag-cycle-min 5 # 最大碎片整理工作量（CPU百分比） # active-defrag-cycle-max 75 # 将从主字典扫描处理的set/hash/zset/list字段的最大数量 # active-defrag-max-scan-fields 1000 Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-02-17 18:28:18 "},"redis/main/":{"url":"redis/main/","title":"REDIS流程","keywords":"","body":"JJJ Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-02-01 17:16:26 "},"redis/main/server.html":{"url":"redis/main/server.html","title":"启动过程","keywords":"","body":"服务的启动过程 初始化全局服务器配置 全局变量server： struct redisServer server; /* Server global state */ 初始化函数initServerConfig()，主要初始化全局变量server的参数： struct redisServer { /* General */ pid_t pid; /* Main process pid. */ char *configfile; /* Absolute config file path, or NULL */ char *executable; /* Absolute executable file path. */ ... /* Mutexes used to protect atomic variables when atomic builtins are * not available. */ pthread_mutex_t lruclock_mutex; pthread_mutex_t next_client_id_mutex; pthread_mutex_t unixtime_mutex; }; Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-02-06 09:32:13 "},"redis/robj/":{"url":"redis/robj/","title":"Redis对象","keywords":"","body":"robj对象 Redis是一个key-value型数据库，key只能是字符串，value可以是字符串、列表、集合、有序集合和哈希，这5种数据类型用结构体robj表示，我们称之为Redis对象。 robj数据结构 typedef struct redisObject { unsigned type:4; // 对象类型（4位=0.5字节） unsigned encoding:4; // 编码（4位=0.5字节） unsigned lru:LRU_BITS; // 记录对象最后一次被应用程序访问的时间（24位=3字节）,LRU时间（相对于全局LRU_clock）或LFU数据（最低有效8位频率和最高有效16位访问时间）。 int refcount; // 引用计数。等于0时表示可以被垃圾回收（4字节） void *ptr; // 数据指针。指向真正的数据(8字节)。比如，一个代表string的robj，它的ptr可能指向一个sds结构；一个代表list的robj，它的ptr可能指向一个quicklist } robj; type字段 encoding字段 #define OBJ_ENCODING_RAW 0 /* Raw representation 原始表示法 */ #define OBJ_ENCODING_INT 1 /* Encoded as integer 整数 */ #define OBJ_ENCODING_HT 2 /* Encoded as hash table 哈希表 */ #define OBJ_ENCODING_ZIPMAP 3 /* Encoded as zipmap 压缩字典 */ #define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. 不再使用 */ #define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist 压缩列表 */ #define OBJ_ENCODING_INTSET 6 /* Encoded as intset 整数集合 */ #define OBJ_ENCODING_SKIPLIST 7 /* Encoded as skiplist 跳表 */ #define OBJ_ENCODING_EMBSTR 8 /* Embedded sds string encoding 简单动态字符串 */ #define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists 快速链表 */ #define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks 流 */ 为多种数据类型提供一种统一的表示方式。 允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。 支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进而节省内存。 Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2022-12-30 16:00:17 "},"redis/string/":{"url":"redis/string/","title":"Redis字符串","keywords":"","body":"简介 字符串存储字节序列，包括文本、序列化对象和二进制数组，是redis最基本的key/value类型的数据结构，也是我们最常用的数据结构。通常用于数据缓存、计数器、分布式锁。 常用函数 函数 命令 描述 set set key value [expiration EX seconds/PX milliseconds] [NX/XX] 设置指定 key 的值 get get key 获取指定 key 的值 setnx setnx key value 只有在 key 不存在时设置 key 的值 incr incr key 将 key 中储存的数字值增一 decr decr key 将 key 中储存的数字值减一 incrby incrby key increment 将 key 所储存的值加上给定的增量值（increment） decrby decrby key increment key 所储存的值减去给定的减量值（decrement） 业务场景 数据缓存 常见功能：高并发场景的数据预热，热点数据缓存（地区列表、活动数据）、共享session等； 常用函数：SET、GET、MSET、MGET 计数器 常见功能：评论数、点赞数、分享数、收藏数、商品的库存数、用户的访问量等； 常用函数：INCR、DECR、INCRBY、DECRBY 分布式锁 常见功能：商品下单、秒杀、扫码抽奖、领取奖励等等； 常用函数：SET、SETNX+EXPIRE SDS结构 struct sds { uint8_t len; // 已使用的长度 uint8_t alloc; // 申请的内存大小 unsigned char flags; // 低3位表示sds的类型，高5位没用 char buf[]; // 字节数组，保存实际数据 }; Redis是基于内存的，而内存永远都是珍贵的资源，每一个字节都很重要，所以针对不同大小的字符串使用不同的结构，也是为了节省内存资源 具体的SDS头信息有5种：sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64，这5种类型的主要区别就在于，数据结构中的len和alloc占据的大小不同，也就是这个结构体能存储的长度不同。结构体的源码如下： /*注意:sdshdr5从未被使用，我们只是直接访问标志字节。然而，这里是为了记录类型为5的SDS字符串的布局。*/ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 低3位存储类型，高5位存储长度 */ char buf[]; /* 柔性数组，存放实际内容 */ }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* buf已使用长度，用1个字节存储 */ uint8_t alloc; /* 总长度，用1个字节存储，最大存储的字符长度为2^8 */ unsigned char flags; /* 低3位存储类型，高5位预留 */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* buf已使用长度，用2个字节存储 */ uint16_t alloc; /* 总长度，用2个字节存储，最大存储的字符长度为256(2^16) */ unsigned char flags; char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* buf已使用长度，用4个字节存储 */ uint32_t alloc; /* 总长度，用4个字节存储，最大存储的字符长度为256(2^32) */ unsigned char flags; char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* buf已使用长度，用8个字节存储 */ uint64_t alloc; /* 总长度，用8个字节存储 */ unsigned char flags; char buf[]; }; value值最大不超过512M。 Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-02-17 18:41:50 "},"redis/question/":{"url":"redis/question/","title":"常见问题","keywords":"","body":"缓存问题 问题 说明 行为 解决方案 缓存穿透 大量请求根本不存在的key 缓存穿透一般是黑客攻击所为，黑客通过发送大量无效的请求给服务器，由于请求的资源根本就不存在，Redis查询不到数据，会一直查询DB，DB就很容易被打垮。 1、非法请求的限制；主要是指参数校验、鉴权校验等，从而一开始就把大量的非法请求拦截在外，这在实际业务开发中是必要的手段；2、对不存在的数据进行缓存；如果数据不存在，返回空，不再请求数据库，但是对方如果一直使用动态不重复的数据请求，这个也是无效的。3、使用布隆过滤器；Redis使用BitMap实现布隆过滤器，将目前所有可以访问到的资源通过多种哈希算法映射到到布隆过滤器中，当一个请求来临的时候先进行布隆过滤器的判断，如果有那么才进行放行，否则就直接拦截。但是布隆过滤器也可能出现哈希冲突，布隆过滤器的特点：不存在的一定不存在，存在的不一定存在。 缓存雪崩 redis中大量的key集体过期 缓存雪崩一般是redis大量的key设置的过期时间一样，大量的key同时过期，一段时间内本应在redis缓存中处理的大量请求，都发送到了数据库进行处理，导致对数据库的压力迅速增大，可能导致数据库崩溃，从而导致整个系统崩溃，就像雪崩一样，引发连锁效应，所以叫缓存雪崩。 1、将过期时间分散；在过期时间上添加随机数，避免缓存集体过期。2、使用锁机制；如果Redis查不到就加上排它锁，其他请求只能进行等待，使重新构建缓存的操作不会在同一时间进行。3、使用多级缓存；redis缓存+其他缓存，不同层使用不同的缓存，可靠性更强。4、缓存降级；直接访问内存部分的数据缓存；直接返回系统设置的默认值。5、后台更新缓存策略；采用定时任务或者消息队列的方式进行redis缓存更新或移除等。 缓存击穿 redis中的某个热点key过期，但是此时有大量的用户访问该过期key 缓存击穿一般出现在高并发系统中，是大量并发用户同时请求到缓存中没有但数据库中有的数据，也就是同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 1、不设置过期时间；对热点数据不设置过期时间。2、使用锁机制；如果Redis查不到就加上排它锁，其他请求只能进行等待，使重新构建缓存的操作不会在同一时间进行。 Copyright © Lsc 2022 all right reserved，powered by Gitbook修订时间： 2023-01-31 16:43:20 "}}